Here is a complete, single-page HTML file containing the Three.js code to render a voxel art version of the flying jetpack cat.

I have designed the code to be procedural and modular, building the cat, the jetpack, and the environment using a voxel grid system. It includes a particle system for the jetpack exhaust and a floating animation.

Save this code as an `.html` file (e.g., `voxel-cat.html`) and open it in any modern web browser.


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Jetpack Cat</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
        }
    </style>
    <!-- Import Three.js via Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="info">Voxel Jetpack Cat</div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const COLORS = {
            orange: 0xE69F46,
            orangeDark: 0xBF7E30,
            white: 0xF0F0F0,
            pink: 0xFFA0A0,
            black: 0x111111,
            eyeGreen: 0x8FBC8F,
            red: 0xD13434,
            silver: 0xAAAAAA,
            thruster: 0x55CCFF
        };

        const VOXEL_SIZE = 5;
        
        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x6EB1FF); // Sky blue
        scene.fog = new THREE.Fog(0x6EB1FF, 200, 900);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(100, 50, 150);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.0;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- Voxel Builder Helper ---
        // Reusing geometry for performance
        const boxGeometry = new THREE.BoxGeometry(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE);
        
        // We will store materials in a cache to avoid recreating them
        const materials = {};
        function getMaterial(colorHex) {
            if (!materials[colorHex]) {
                materials[colorHex] = new THREE.MeshStandardMaterial({ 
                    color: colorHex,
                    roughness: 0.8
                });
            }
            return materials[colorHex];
        }

        function createVoxel(x, y, z, colorHex, parent) {
            const mesh = new THREE.Mesh(boxGeometry, getMaterial(colorHex));
            mesh.position.set(x * VOXEL_SIZE, y * VOXEL_SIZE, z * VOXEL_SIZE);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            parent.add(mesh);
            return mesh;
        }

        // --- Character Construction ---
        const catGroup = new THREE.Group();
        scene.add(catGroup);

        // 1. Body (Torso)
        // A blocky oval shape
        for (let y = -2; y <= 3; y++) {
            for (let x = -2; x <= 2; x++) {
                for (let z = -1; z <= 1; z++) {
                    // Create a harness/belly patch
                    let color = COLORS.orange;
                    if (z > 0 && x > -2 && x < 2 && y < 2) color = COLORS.white; // Belly
                    
                    // Jetpack Harness straps
                    if (z === 1 && (x === -1 || x === 1)) color = COLORS.silver; // Back Straps
                    if (z === 1.2 && y === 0) color = COLORS.silver; // Horizontal strap

                    createVoxel(x, y, z, color, catGroup);
                }
            }
        }

        // 2. Head
        const headGroup = new THREE.Group();
        headGroup.position.set(0, 4 * VOXEL_SIZE, 0); // Place on top of body
        catGroup.add(headGroup);

        for (let y = 0; y < 5; y++) {
            for (let x = -3; x <= 3; x++) {
                for (let z = -2; z <= 2; z++) {
                    let color = COLORS.orange;
                    
                    // Stripes/Patterns
                    if (y === 4 && x % 2 === 0) color = COLORS.orangeDark;
                    
                    // Muzzle area
                    if (z === 2 && y < 2 && x > -2 && x < 2) color = COLORS.white;

                    // Don't fill corners to make it rounder
                    if ((x === -3 || x === 3) && (z === -2 || z === 2)) continue;
                    
                    createVoxel(x, y, z, color, headGroup);
                }
            }
        }

        // Face details
        createVoxel(0, 1.5, 3, COLORS.pink, headGroup); // Nose
        createVoxel(-1.5, 2.5, 2.1, COLORS.eyeGreen, headGroup); // Left Eye
        createVoxel(1.5, 2.5, 2.1, COLORS.eyeGreen, headGroup); // Right Eye
        createVoxel(-1.5, 2.5, 2.4, COLORS.black, headGroup); // Pupil
        createVoxel(1.5, 2.5, 2.4, COLORS.black, headGroup); // Pupil

        // Whiskers (Visualized as single voxels sticking out)
        createVoxel(-3.2, 1, 1, COLORS.white, headGroup).scale.set(0.5, 0.2, 0.2);
        createVoxel(-3.5, 0.5, 1, COLORS.white, headGroup).scale.set(0.5, 0.2, 0.2);
        createVoxel(3.2, 1, 1, COLORS.white, headGroup).scale.set(0.5, 0.2, 0.2);
        createVoxel(3.5, 0.5, 1, COLORS.white, headGroup).scale.set(0.5, 0.2, 0.2);

        // Ears
        function buildEar(sign) {
            createVoxel(sign * 2, 5, 0, COLORS.orange, headGroup);
            createVoxel(sign * 2, 6, 0, COLORS.orange, headGroup);
            createVoxel(sign * 1, 5, 0, COLORS.orange, headGroup); // Inner base
            createVoxel(sign * 2, 5, 1, COLORS.pink, headGroup); // Inner ear pink
        }
        buildEar(1);
        buildEar(-1);

        // 3. Limbs
        
        // Left Arm (Down)
        const lArm = new THREE.Group();
        lArm.position.set(-2.5 * VOXEL_SIZE, 2 * VOXEL_SIZE, 0.5 * VOXEL_SIZE);
        catGroup.add(lArm);
        createVoxel(0, 0, 0, COLORS.orange, lArm);
        createVoxel(0, -1, 0, COLORS.orange, lArm);
        createVoxel(0, -2, 0, COLORS.white, lArm); // Paw

        // Right Arm (Up/Waving)
        const rArm = new THREE.Group();
        rArm.position.set(2.5 * VOXEL_SIZE, 2 * VOXEL_SIZE, 0.5 * VOXEL_SIZE);
        catGroup.add(rArm);
        // Rotate the whole arm group to point up
        rArm.rotation.z = -Math.PI / 4; 
        rArm.rotation.x = -Math.PI / 4;
        createVoxel(0, 0, 0, COLORS.orange, rArm);
        createVoxel(1, 0, 0, COLORS.orange, rArm);
        createVoxel(2, 0, 0, COLORS.white, rArm); // Paw
        // Paw beans
        createVoxel(2.1, 0.1, 0.1, COLORS.black, rArm).scale.set(0.2, 0.5, 0.5);

        // Legs (Dangling)
        function buildLeg(x) {
            const leg = new THREE.Group();
            leg.position.set(x * VOXEL_SIZE, -2.5 * VOXEL_SIZE, 0);
            leg.rotation.x = Math.PI / 6; // Dangle backward slightly
            catGroup.add(leg);
            createVoxel(0, 0, 0, COLORS.orange, leg);
            createVoxel(0, -1, 0, COLORS.orange, leg);
            createVoxel(0, -2, 0, COLORS.white, leg); // Foot
        }
        buildLeg(-1.5);
        buildLeg(1.5);

        // Tail
        const tail = new THREE.Group();
        tail.position.set(0, -2 * VOXEL_SIZE, -1.5 * VOXEL_SIZE);
        catGroup.add(tail);
        for(let i=0; i<5; i++) {
             createVoxel(0, -i, -i*0.5, (i%2===0 ? COLORS.orange : COLORS.orangeDark), tail);
        }

        // 4. Jetpack
        const jetpack = new THREE.Group();
        jetpack.position.set(0, 0, -2 * VOXEL_SIZE); // Behind the cat
        catGroup.add(jetpack);

        // Main tanks
        function buildTank(x) {
            for(let y=-2; y<3; y++) {
                createVoxel(x, y, 0, COLORS.red, jetpack);
                createVoxel(x, y, -1, COLORS.red, jetpack);
                // Rounding
                if(y !== -2 && y !== 2) {
                     createVoxel(x - Math.sign(x), y, 0, COLORS.red, jetpack);
                }
            }
            // Top cap
            createVoxel(x, 3, 0, COLORS.silver, jetpack);
            // Bottom nozzle
            createVoxel(x, -3, 0, COLORS.silver, jetpack);
        }
        buildTank(-2.5);
        buildTank(2.5);

        // Center connector (White panel in image)
        for(let x=-1; x<=1; x++) {
            for(let y=-1; y<=2; y++) {
                createVoxel(x, y, 0.5, COLORS.white, jetpack);
            }
        }
        createVoxel(0, 1.5, 0.6, COLORS.red, jetpack).scale.set(0.5,0.5,0.2); // Button

        // --- Particle System (Exhaust) ---
        const particleGeometry = new THREE.BoxGeometry(VOXEL_SIZE*0.8, VOXEL_SIZE*0.8, VOXEL_SIZE*0.8);
        const particleMaterial = new THREE.MeshBasicMaterial({ 
            color: COLORS.thruster, 
            transparent: true, 
            opacity: 0.8 
        });
        
        const particles = [];

        function createParticle(xOffset) {
            // Spawn position relative to world
            const p = new THREE.Mesh(particleGeometry, particleMaterial.clone());
            
            // Get world position of the nozzle
            const nozzleY = -3 * VOXEL_SIZE;
            const nozzleZ = -2 * VOXEL_SIZE;
            
            // Adjust for Cat's movement
            p.position.x = xOffset * VOXEL_SIZE;
            p.position.y = nozzleY + catGroup.position.y - 5; // slightly below
            p.position.z = nozzleZ;

            // Add some randomness
            p.position.x += (Math.random() - 0.5) * 5;
            p.position.z += (Math.random() - 0.5) * 5;

            scene.add(p);
            particles.push({ mesh: p, life: 1.0, speed: 2.0 + Math.random() });
        }

        // --- Environment (Clouds) ---
        function createCloud(x, y, z, scale) {
            const cloud = new THREE.Group();
            const mat = getMaterial(COLORS.white);
            
            // Random blob generator
            const chunks = 5 + Math.random() * 5;
            for(let i=0; i<chunks; i++) {
                const m = new THREE.Mesh(boxGeometry, mat);
                m.position.set(
                    (Math.random()-0.5)*3 * VOXEL_SIZE,
                    (Math.random()-0.5)*2 * VOXEL_SIZE,
                    (Math.random()-0.5)*3 * VOXEL_SIZE
                );
                cloud.add(m);
            }
            cloud.position.set(x, y, z);
            cloud.scale.setScalar(scale);
            scene.add(cloud);
        }

        for(let i=0; i<15; i++) {
            createCloud(
                (Math.random()-0.5) * 400,
                (Math.random()-0.5) * 200,
                (Math.random()-0.5) * 200 - 100,
                2 + Math.random()
            );
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            controls.update();

            // Floating Animation
            catGroup.position.y = Math.sin(time * 2) * 5;
            catGroup.rotation.x = Math.sin(time) * 0.1; // Tilt forward/back slightly

            // Paw wave
            rArm.rotation.z = -Math.PI / 4 + Math.sin(time * 10) * 0.2;

            // Spawn Particles
            if (Math.random() > 0.2) { // controlled spawn rate
                createParticle(-2.5); // Left tank nozzle x
                createParticle(2.5);  // Right tank nozzle x
            }

            // Update Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= 0.02;
                p.mesh.position.y -= p.speed;
                p.mesh.rotation.x += 0.1;
                p.mesh.rotation.y += 0.1;
                p.mesh.scale.setScalar(p.life);
                p.mesh.material.opacity = p.life;

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>