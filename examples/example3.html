Here is a single-page HTML file containing the Three.js code. This code procedurally generates a voxel scene featuring a multi-tiered red pagoda, a lush garden with varying shades of green, a pond, and winding stone paths, closely inspired by the reference image.

I have optimized it using `InstancedMesh` to render thousands of voxels efficiently at 60fps.


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Japanese Garden</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: sans-serif;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>
    <div id="info">Voxel Garden Inspired by Image - Drag to Rotate, Scroll to Zoom</div>
    <!-- Three.js CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONFIGURATION ---
        const VOXEL_SIZE = 1;
        const WORLD_SIZE = 80;
        
        // Color Palette extracted/inspired by the image
        const PALETTE = {
            PAGODA_RED: 0xB83228,
            PAGODA_WHITE: 0xEEEEEE,
            ROOF_DARK: 0x222222,
            ROOF_HIGHLIGHT: 0x444444,
            GOLD: 0xFFD700,
            GRASS_LIGHT: 0x6A8F36,
            GRASS_DARK: 0x4A6B23,
            TREE_DARK: 0x1E3F20,
            TREE_LIGHT: 0x386630,
            BUSH_LIME: 0x8FB339,
            WATER: 0x4FA4B8,
            STONE: 0x999999,
            DIRT: 0x5C4033
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        scene.fog = new THREE.Fog(0x87CEEB, 40, 130);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-60, 50, 60); // Isometric-ish view similar to photo
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 10, 0);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(-50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 500;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        scene.add(sunLight);

        // --- VOXEL ENGINE ---
        // We will store all voxels in a list and render them using a single InstancedMesh for performance
        const voxels = [];

        function addVoxel(x, y, z, color) {
            voxels.push({ x, y, z, color });
        }

        // --- GENERATION FUNCTIONS ---

        // 1. Terrain & Water
        function generateTerrain() {
            const noiseScale = 0.1;
            for (let x = -WORLD_SIZE / 2; x < WORLD_SIZE / 2; x++) {
                for (let z = -WORLD_SIZE / 2; z < WORLD_SIZE / 2; z++) {
                    
                    // Basic elevation noise
                    let y = Math.floor(Math.sin(x * 0.05) * Math.cos(z * 0.05) * 2);
                    
                    // Pond area logic (Circle equation roughly)
                    const distFromPondCenter = Math.sqrt(Math.pow(x + 15, 2) + Math.pow(z + 15, 2));
                    
                    if (distFromPondCenter < 12) {
                        // Water bed
                        addVoxel(x, -2, z, PALETTE.DIRT);
                        addVoxel(x, -1, z, PALETTE.WATER);
                    } else {
                        // Grass with random variation
                        const grassColor = Math.random() > 0.7 ? PALETTE.GRASS_LIGHT : PALETTE.GRASS_DARK;
                        addVoxel(x, y, z, grassColor);
                        // Add dirt below
                        addVoxel(x, y - 1, z, PALETTE.DIRT);
                    }
                }
            }
        }

        // 2. Stone Path
        function generatePath() {
            // Simple winding path function
            for (let t = -30; t < 30; t += 0.5) {
                const x = Math.floor(t);
                const z = Math.floor(Math.sin(t * 0.2) * 15 + 10);
                
                // Add stone, remove grass at this pos if exists (simplified by just placing on top)
                // In a real voxel engine we'd check grid, here we just layer
                const y = Math.floor(Math.sin(x * 0.05) * Math.cos(z * 0.05) * 2) + 1;
                
                // Make path 2 wide
                addVoxel(x, y - 0.2, z, PALETTE.STONE);
                addVoxel(x + 1, y - 0.2, z, PALETTE.STONE);
            }
        }

        // 3. The Pagoda
        function buildPagoda(bx, bz) {
            const floors = 5;
            const baseWidth = 8;
            const startY = 0;

            // Base Platform
            for(let x = bx - 5; x <= bx + 5; x++) {
                for(let z = bz - 5; z <= bz + 5; z++) {
                    addVoxel(x, startY + 1, z, PALETTE.STONE);
                }
            }

            let currentY = startY + 2;

            for (let f = 0; f < floors; f++) {
                let width = baseWidth - f; // Taper slightly
                if(width < 4) width = 4;
                const roofOverhang = 2;

                // Walls (Red with White corners)
                const wallHeight = 3;
                for (let y = 0; y < wallHeight; y++) {
                    for (let x = -width/2; x <= width/2; x++) {
                        for (let z = -width/2; z <= width/2; z++) {
                            // Only draw walls (hollow inside)
                            if (Math.abs(x) >= width/2 - 1 || Math.abs(z) >= width/2 - 1) {
                                // Corners are white
                                const isCorner = (Math.abs(x) >= width/2 - 1 && Math.abs(z) >= width/2 - 1);
                                addVoxel(bx + x, currentY + y, bz + z, isCorner ? PALETTE.PAGODA_WHITE : PALETTE.PAGODA_RED);
                            }
                        }
                    }
                }
                currentY += wallHeight;

                // Roof (Dark Grey with upturned corners)
                const roofWidth = width + roofOverhang * 2;
                for (let x = -roofWidth/2; x <= roofWidth/2; x++) {
                    for (let z = -roofWidth/2; z <= roofWidth/2; z++) {
                        // Pyramid slope
                        let dist = Math.max(Math.abs(x), Math.abs(z));
                        let slopeY = 0;
                        
                        // Flat part
                        if (dist > width/2) slopeY = 0;
                        else slopeY = 1;

                        // Upturn corners
                        if (Math.abs(x) === Math.floor(roofWidth/2) && Math.abs(z) === Math.floor(roofWidth/2)) {
                            slopeY += 1; 
                        }

                        addVoxel(bx + x, currentY + slopeY, bz + z, PALETTE.ROOF_DARK);
                    }
                }
                currentY += 1; // Step up for next floor
            }

            // Spire
            for(let y = 0; y < 8; y++) {
                addVoxel(bx, currentY + y, bz, PALETTE.GOLD);
                if (y === 0 || y === 2 || y === 4) {
                    addVoxel(bx + 1, currentY + y, bz, PALETTE.GOLD);
                    addVoxel(bx - 1, currentY + y, bz, PALETTE.GOLD);
                    addVoxel(bx, currentY + y, bz + 1, PALETTE.GOLD);
                    addVoxel(bx, currentY + y, bz - 1, PALETTE.GOLD);
                }
            }
        }

        // 4. Vegetation
        function buildTree(tx, tz, type) {
            const groundY = Math.floor(Math.sin(tx * 0.05) * Math.cos(tz * 0.05) * 2);
            
            if (type === 'pine') {
                // Trunk
                const height = 8 + Math.random() * 5;
                for(let y = 0; y < height; y++) {
                    addVoxel(tx, groundY + y, tz, PALETTE.DIRT);
                }
                // Leaves (Conical layers)
                let radius = 4;
                for(let y = 4; y < height + 3; y+=2) {
                    for(let lx = -radius; lx <= radius; lx++) {
                        for(let lz = -radius; lz <= radius; lz++) {
                            if (lx*lx + lz*lz <= radius*radius) {
                                addVoxel(tx + lx, groundY + y, tz + lz, PALETTE.TREE_DARK);
                            }
                        }
                    }
                    radius = Math.max(0, radius - 1);
                }
            } else if (type === 'bush') {
                const radius = 2 + Math.random();
                for(let x = -radius; x <= radius; x++) {
                    for(let y = 0; y <= radius; y++) {
                        for(let z = -radius; z <= radius; z++) {
                            if (x*x + y*y + z*z <= radius*radius) {
                                addVoxel(tx + x, groundY + y, tz + z, PALETTE.BUSH_LIME);
                            }
                        }
                    }
                }
            }
        }

        function generateNature() {
            // Scatter Pine Trees
            for(let i = 0; i < 40; i++) {
                let x = (Math.random() - 0.5) * (WORLD_SIZE - 10);
                let z = (Math.random() - 0.5) * (WORLD_SIZE - 10);
                
                // Keep away from Pagoda center and Pond
                const distPagoda = Math.sqrt(Math.pow(x - 20, 2) + Math.pow(z - (-10), 2));
                const distPond = Math.sqrt(Math.pow(x + 15, 2) + Math.pow(z + 15, 2));

                if (distPagoda > 15 && distPond > 14) {
                    buildTree(Math.floor(x), Math.floor(z), 'pine');
                }
            }

            // Scatter Round Bushes
            for(let i = 0; i < 50; i++) {
                let x = (Math.random() - 0.5) * (WORLD_SIZE - 5);
                let z = (Math.random() - 0.5) * (WORLD_SIZE - 5);
                
                const distPond = Math.sqrt(Math.pow(x + 15, 2) + Math.pow(z + 15, 2));
                // Bushes near pond are nice
                
                // Don't spawn inside pagoda
                if (Math.abs(x - 20) > 6 || Math.abs(z + 10) > 6) {
                    if (distPond > 10) // Don't spawn in water
                        buildTree(Math.floor(x), Math.floor(z), 'bush');
                }
            }
        }

        // --- EXECUTE GENERATION ---
        generateTerrain();
        generatePath();
        buildPagoda(20, -10); // Place Pagoda offset from center
        generateNature();

        // --- BUILD MESH ---
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshLambertMaterial({ color: 0xffffff }); // White base, colored by instance
        const mesh = new THREE.InstancedMesh(geometry, material, voxels.length);
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        const dummy = new THREE.Object3D();
        const color = new THREE.Color();

        voxels.forEach((voxel, i) => {
            dummy.position.set(voxel.x, voxel.y, voxel.z);
            dummy.updateMatrix();
            mesh.setMatrixAt(i, dummy.matrix);
            
            color.setHex(voxel.color);
            mesh.setColorAt(i, color);
        });

        scene.add(mesh);

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>